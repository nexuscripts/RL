-- Aimbot (Rayfield-ready, screen-center lock)

if game.PlaceId ~= 135856908115931 then
    return
end

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")
local Workspace         = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

------------------------------------------------------------
-- GLOBAL TOGGLE STATE (controlled by MobileReticle / Rayfield)
------------------------------------------------------------
if not getgenv then getgenv = function() return _G end end

-- Default OFF; Rayfield will turn it ON through MobileReticle
getgenv().Aimbot_Enabled = (getgenv().Aimbot_Enabled ~= nil) and getgenv().Aimbot_Enabled or false

----------------------------------------------------------------
-- Configuration
----------------------------------------------------------------
local player = Players.LocalPlayer
local cam    = workspace.CurrentCamera

local RETICLE_OVERRIDE_TARGET = false
local CAM_OFFSET = Vector3.new(0,0,0)

----------------------------------------------------------------
-- State
----------------------------------------------------------------
local isEnabled          = getgenv().Aimbot_Enabled
local currentTargetPart  = nil
local centerMode         = true

----------------------------------------------------------------
-- Skins folders (for Guns / Knives classification)
----------------------------------------------------------------
local gunsSkinsFolder, knifeSkinsFolder do
    local skins = ReplicatedStorage:FindFirstChild("Skins")
    if skins then
        gunsSkinsFolder  = skins:FindFirstChild("Guns")
        knifeSkinsFolder = skins:FindFirstChild("Knives")
    end
end

----------------------------------------------------------------
-- TEAM FILTER: find my RunningGame + team; check opponents
----------------------------------------------------------------
local runningGamesRoot = Workspace:FindFirstChild("RunningGames")
local currentGameFolder        -- e.g. Workspace.RunningGames.G3...
local alivePlayersFolder       -- .AlivePlayers
local myTeamName               -- "TeamBlue" | "TeamRed" | nil
local lastTeamScan = 0

-- track if we've actually joined a round this session
local joinedRound = false

-- survive-death team memory + GUI fallback
local lastKnownTeamName = nil
local function deriveTeamFromGui()
    local pg = player:FindFirstChild("PlayerGui")
    if not pg then return nil end
    local main = pg:FindFirstChild("Main")
    if not main then return nil end
    local mgf  = main:FindFirstChild("MainGameFrame")
    if not mgf then return nil end
    local pf   = mgf:FindFirstChild("PlayersFrame")
    if not pf then return nil end
    if pf:FindFirstChild("TeamBlueFrame") then return "TeamBlue" end
    if pf:FindFirstChild("TeamRedFrame")  then return "TeamRed"  end
    return nil
end

local TEAMS = { "TeamBlue", "TeamRed" }
local function otherTeam(team)
    if team == "TeamBlue" then return "TeamRed" end
    if team == "TeamRed" then return "TeamBlue" end
end

local function locateMyGameAndTeam()
    runningGamesRoot = runningGamesRoot or Workspace:FindFirstChild("RunningGames")
    if not runningGamesRoot then return end

    local foundGame, foundAlive, foundTeam = nil, nil, nil

    for _, gameFolder in ipairs(runningGamesRoot:GetChildren()) do
        local alive = gameFolder:FindFirstChild("AlivePlayers")
        if alive and alive:IsA("Folder") then
            for _, teamName in ipairs(TEAMS) do
                local teamFolder = alive:FindFirstChild(teamName)
                if teamFolder and teamFolder:FindFirstChild(player.Name) then
                    foundGame  = gameFolder
                    foundAlive = alive
                    foundTeam  = teamName
                    break
                end
            end
        end
        if foundGame then break end
    end

    if foundGame and foundAlive then
        currentGameFolder  = foundGame
        alivePlayersFolder = foundAlive
        myTeamName         = foundTeam
        lastKnownTeamName  = myTeamName or lastKnownTeamName
        joinedRound        = true
        return
    end

    if not alivePlayersFolder then
        for _, gameFolder in ipairs(runningGamesRoot:GetChildren()) do
            local alive = gameFolder:FindFirstChild("AlivePlayers")
            if alive and alive:IsA("Folder") then
                local tb = alive:FindFirstChild("TeamBlue")
                local tr = alive:FindFirstChild("TeamRed")
                if tb or tr then
                    currentGameFolder  = gameFolder
                    alivePlayersFolder = alive
                    break
                end
            end
        end
    end

    if not myTeamName then
        myTeamName = deriveTeamFromGui() or lastKnownTeamName
    end
    if myTeamName then
        lastKnownTeamName = myTeamName
    end
end

local function getPlayerTeamName(plr)
    if not alivePlayersFolder then return nil end
    for _, teamName in ipairs(TEAMS) do
        local tf = alivePlayersFolder:FindFirstChild(teamName)
        if tf and tf:FindFirstChild(plr.Name) then
            return teamName
        end
    end
    return nil
end

local function isOnOppositeTeam(plr)
    if (os.clock() - lastTeamScan) > 1.0 or not alivePlayersFolder then
        locateMyGameAndTeam()
        lastTeamScan = os.clock()
    end
    local myTeam = myTeamName or lastKnownTeamName or deriveTeamFromGui()
    if not myTeam then return false end
    local pt = getPlayerTeamName(plr)
    return pt ~= nil and pt == otherTeam(myTeam)
end

local function isInRoundNow()
    if not alivePlayersFolder then return false end
    for _, teamName in ipairs(TEAMS) do
        local tf = alivePlayersFolder:FindFirstChild(teamName)
        if tf and tf:FindFirstChild(player.Name) then
            return true
        end
    end
    return false
end

----------------------------------------------------------------
-- Camera helper
----------------------------------------------------------------
local function setCameraAbove(on)
    local char = player.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.CameraOffset = on and CAM_OFFSET or Vector3.new(0,0,0)
    end
end

player.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    if isEnabled then setCameraAbove(true) end
end)
if player.Character and isEnabled then setCameraAbove(true) end

----------------------------------------------------------------
-- GUI (white crosshair; red enemy dots)
----------------------------------------------------------------
local gui = Instance.new("ScreenGui")
gui.Name, gui.IgnoreGuiInset, gui.ResetOnSpawn =
    "MobileReticleGui", true, false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
gui.Parent = player:WaitForChild("PlayerGui")

local cross = Instance.new("Frame")
cross.Size, cross.AnchorPoint =
    UDim2.new(0,3,0,3), Vector2.new(0.5,0.5)
cross.Position          = UDim2.new(0.5,0,0.5,0)
cross.BackgroundColor3  = Color3.fromRGB(255,255,255)
cross.BorderSizePixel   = 0
cross.Visible           = false -- start hidden until enabled
cross.ZIndex            = 10
cross.Parent            = gui
local crossStroke = Instance.new("UIStroke", cross)
crossStroke.Thickness = 1
crossStroke.ZIndex    = 11

local enemyDots = {}  -- [userId] = Frame
local function getOrCreateEnemyDot(uid)
    local f = enemyDots[uid]
    if f and f.Parent then return f end
    f = Instance.new("Frame")
    f.Size, f.AnchorPoint = UDim2.new(0,3,0,3), Vector2.new(0.5,0.5)
    f.BackgroundColor3    = Color3.fromRGB(255,0,0)
    f.BorderSizePixel     = 0
    f.Visible             = false
    f.ZIndex              = 5
    f.Parent              = gui
    local s = Instance.new("UIStroke", f)
    s.Thickness = 1
    s.ZIndex    = 6
    enemyDots[uid] = f
    return f
end

local function removeEnemyDot(uid)
    local f = enemyDots[uid]
    if f then f:Destroy(); enemyDots[uid] = nil end
end
Players.PlayerRemoving:Connect(function(plr)
    removeEnemyDot(plr.UserId)
end)

----------------------------------------------------------------
-- Targeting helpers (opposite-team only)
----------------------------------------------------------------
local OFFSET_LEFT_STUDS = 0

local function isSelectable(p)
    return p ~= player
       and isOnOppositeTeam(p)
      and p.Character
      and p.Character:FindFirstChild("HumanoidRootPart") ~= nil
end

-- ✅ NEW: closest enemy to the CENTER of the screen (original behavior)
local function getClosestScreenPlayer()
    if not cam then return nil end

    local viewportSize = cam.ViewportSize
    local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)

    local bestPart = nil
    local bestDist2 = math.huge

    for _, p in ipairs(Players:GetPlayers()) do
        if isSelectable(p) then
            local hrp = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local vp, onScreen = cam:WorldToViewportPoint(hrp.Position)
                if onScreen and vp.Z > 0 then
                    local pos2 = Vector2.new(vp.X, vp.Y)
                    local d2 = (pos2 - screenCenter).Magnitude^2
                    if d2 < bestDist2 then
                        bestDist2 = d2
                        bestPart = hrp
                    end
                end
            end
        end
    end

    return bestPart
end

----------------------------------------------------------------
-- Aim (no prediction)
----------------------------------------------------------------
local function shifted(pos)
    return pos - cam.CFrame.RightVector*OFFSET_LEFT_STUDS
end

local function aimCFrame()
    if currentTargetPart then
        local pos = currentTargetPart.Position
        return CFrame.new(shifted(pos))
    end
    return CFrame.new(cam.CFrame.Position)
end

----------------------------------------------------------------
-- Mouse metatable hijack
----------------------------------------------------------------
do
    local mouse = player:GetMouse()
    if mouse then
        local mt = getrawmetatable(mouse)
        local old = mt.__index
        setreadonly(mt,false)
        mt.__index = function(t,k)
            if isEnabled and currentTargetPart ~= nil then
                if k=="Hit" then
                    return aimCFrame()
                elseif k=="Target" and RETICLE_OVERRIDE_TARGET then
                    return currentTargetPart
                elseif k=="X" or k=="Y" then
                    local sp = cam:WorldToViewportPoint(aimCFrame().Position)
                    return (k=="X") and sp.X or sp.Y
                end
            end
            return old(t,k)
        end
        setreadonly(mt,true)
    end
end

----------------------------------------------------------------
-- Hard reset helper
----------------------------------------------------------------
local function clearAll()
    currentTargetPart = nil
    setCameraAbove(false)
    centerMode = true
    cross.Visible = false
    cross.Position = UDim2.new(0.5,0,0.5,0)
    UserInputService.MouseBehavior    = Enum.MouseBehavior.Default
    UserInputService.MouseIconEnabled = true
    for _,f in pairs(enemyDots) do f.Visible = false end
end

----------------------------------------------------------------
-- LOS + equip helpers / gun & knife classification
----------------------------------------------------------------
local function isClearSight(toPart)
    if not toPart then return false end

    local char = player.Character
    local hrp  = char and char:FindFirstChild("HumanoidRootPart")

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {
        char,
        toPart.Parent
    }

    local function checkOrigin(origin)
        local direction = toPart.Position - origin
        local result = Workspace:Raycast(origin, direction, params)
        return result == nil
    end

    if not checkOrigin(cam.CFrame.Position) then
        return false
    end

    if hrp and not checkOrigin(hrp.Position) then
        return false
    end

    return true
end

local lastEquipTick = 0
local lastEquippedName = nil

local suppressAutoEquip = false
local lastHoldingGun    = false

local function getToolByPathLike(obj)
    if not obj then return nil end
    if obj:IsA("Tool") then return obj end
    if obj:IsA("StringValue") or obj:IsA("ObjectValue") then
        local v = obj.Value
        if typeof(v) == "Instance" and v:IsA("Tool") then
            return v
        elseif typeof(v) == "string" then
            local bp = player:FindFirstChild("Backpack")
            if bp then
                return bp:FindFirstChild(v)
            end
        end
    end
    return nil
end

local function safeEquip(tool)
    if not tool then return false end
    if not player.Character then return false end
    if tool.Parent == player.Character then return true end
    tool.Parent = player.Character
    return tool.Parent == player.Character
end

local function getHeldTool()
    local char = player.Character
    if not char then return nil end
    for _,c in ipairs(char:GetChildren()) do
        if c:IsA("Tool") then
            return c
        end
    end
    return nil
end

local function isKnifeTool(tool)
    if not tool or not knifeSkinsFolder then return false end
    return knifeSkinsFolder:FindFirstChild(tool.Name) ~= nil
end

local function isGun(tool)
    if not (tool and tool:IsA("Tool") and gunsSkinsFolder) then return false end
    return gunsSkinsFolder:FindFirstChild(tool.Name) ~= nil
end

local function equipPreferredGun()
    if os.clock() - lastEquipTick < 0.25 then return end
    lastEquipTick = os.clock()

    local char = player.Character
    local heldGun = nil
    if char then
        for _,c in ipairs(char:GetChildren()) do
            if c:IsA("Tool") and isGun(c) then
                heldGun = c
                break
            end
        end
    end

    if heldGun then
        lastEquippedName = heldGun.Name
        return
    end

    local eqCandidate = getToolByPathLike(player:FindChild("EquippedGun"))
    if eqCandidate and isGun(eqCandidate) and safeEquip(eqCandidate) then
        lastEquippedName = eqCandidate.Name
        return
    end

    local bp = player:FindFirstChild("Backpack")
    if bp and gunsSkinsFolder then
        for _, gunSkin in ipairs(gunsSkinsFolder:GetChildren()) do
            local t = bp:FindFirstChild(gunSkin.Name)
            if t and t:IsA("Tool") and safeEquip(t) then
                lastEquippedName = t.Name
                return
            end
        end
    end
end

local function playerFromPart(part)
    if not part then return nil end
    local model = part:FindFirstAncestorOfClass("Model")
    if not model then return nil end
    local hum = model:FindFirstChildOfClass("Humanoid")
    if not hum then return nil end
    return Players:GetPlayerFromCharacter(model)
end

local function isViewerAlive()
    local char = player.Character
    local hum  = char and char:FindFirstChildOfClass("Humanoid")
    local aliveByHealth = hum and hum.Health > 0
    local aliveByFolder = false
    if alivePlayersFolder then
        local team = myTeamName or lastKnownTeamName
        if team then
            local tf = alivePlayersFolder:FindFirstChild(team)
            aliveByFolder = tf and tf:FindFirstChild(player.Name) ~= nil
        end
    end
    return aliveByHealth or aliveByFolder
end

----------------------------------------------------------------
-- MAIN RENDER LOOP
----------------------------------------------------------------
RunService.RenderStepped:Connect(function()
    -- sync local state to global (Rayfield may have changed it)
    if isEnabled ~= getgenv().Aimbot_Enabled then
        isEnabled = getgenv().Aimbot_Enabled
        if not isEnabled then
            clearAll()
        end
    end

    if (os.clock() - lastTeamScan) > 1.0 then
        locateMyGameAndTeam()
        lastTeamScan = os.clock()
    end

    if not isEnabled then
        currentTargetPart = nil
        cross.Visible = false
        UserInputService.MouseBehavior    = Enum.MouseBehavior.Default
        UserInputService.MouseIconEnabled = true
        for _,f in pairs(enemyDots) do f.Visible = false end
        return
    end

    local inRoundNow = isInRoundNow()
    if inRoundNow then joinedRound = true end
    local featuresActive = joinedRound or inRoundNow
    if not featuresActive then
        currentTargetPart = nil
        UserInputService.MouseBehavior    = Enum.MouseBehavior.Default
        UserInputService.MouseIconEnabled = true
        for _,f in pairs(enemyDots) do f.Visible = false end
        cross.Visible  = true
        cross.Position = UDim2.new(0.5,0,0.5,0)
        return
    end

    local heldTool = getHeldTool()
    local knifeBlockingAimbot = heldTool and isKnifeTool(heldTool) or false

    if knifeBlockingAimbot then
        currentTargetPart = nil
        suppressAutoEquip = false
        lastHoldingGun    = false

        UserInputService.MouseBehavior    = Enum.MouseBehavior.Default
        UserInputService.MouseIconEnabled = true
        cross.Visible = false
        for _,f in pairs(enemyDots) do f.Visible = false end
        return
    end

    local viewerAlive = isViewerAlive()

    -- ✅ Screen-center targeting: choose enemy closest to the middle of the screen
    local newTarget = getClosestScreenPlayer()
    currentTargetPart = newTarget

    if currentTargetPart then
        centerMode = false
        UserInputService.MouseBehavior    = Enum.MouseBehavior.LockCenter
        UserInputService.MouseIconEnabled = false

        if viewerAlive then
            local sp = cam:WorldToViewportPoint(aimCFrame().Position)
            cross.Visible  = true
            cross.Position = UDim2.new(0,sp.X,0,sp.Y)
        else
            cross.Visible = false
        end
    else
        centerMode = true
        UserInputService.MouseBehavior    = Enum.MouseBehavior.Default
        UserInputService.MouseIconEnabled = true

        if viewerAlive then
            cross.Visible  = true
            cross.Position = UDim2.new(0.5,0,0.5,0)
        else
            cross.Visible = false
        end
    end

    -- enemy red dots (ESP-style)
    for _,p in ipairs(Players:GetPlayers()) do
        local uid = p.UserId
        local dot = enemyDots[uid]
        if isSelectable(p) then
            dot = dot or getOrCreateEnemyDot(uid)
            local hrp = p.Character.HumanoidRootPart
            local vp, on = cam:WorldToViewportPoint(hrp.Position)
            if on and vp.Z > 0 then
                dot.Visible  = true
                dot.Position = UDim2.new(0, vp.X, 0, vp.Y)
            else
                dot.Visible = false
            end
        else
            if dot then dot.Visible = false end
        end
    end

    local holdingGunNow   = isGun(heldTool)

    local targetPlayer    = nil
    local hasClearLOS     = false
    if currentTargetPart then
        targetPlayer = playerFromPart(currentTargetPart)
        if targetPlayer
            and isOnOppositeTeam(targetPlayer)
            and isClearSight(currentTargetPart) then
            hasClearLOS = true
        end
    end

    if lastHoldingGun and not holdingGunNow and hasClearLOS then
        suppressAutoEquip = true
    end

    if suppressAutoEquip and not hasClearLOS then
        suppressAutoEquip = false
    end

    lastHoldingGun = holdingGunNow

    if hasClearLOS and not suppressAutoEquip then
        equipPreferredGun()
    end
end)

----------------------------------------------------------------
-- Public API for Rayfield
----------------------------------------------------------------
getgenv().MobileReticle = {
    TurnOn  = function()
        if not isEnabled then
            isEnabled = true
            getgenv().Aimbot_Enabled = true
            centerMode = false
            setCameraAbove(true)
        end
    end,
    TurnOff = function()
        if isEnabled then
            isEnabled = false
            getgenv().Aimbot_Enabled = false
            clearAll()
        end
    end,
    IsEnabled        = function() return isEnabled end,
    IsOverrideActive = function() return centerMode or isEnabled end,
}
